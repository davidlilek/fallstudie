---
title: "Fallstudie - Data New 002"
author: "Daniel Zimmermann / David Lilek"
output:
  html_document:
    df_print: paged
    fig.align: center
    self_contained: yes 
    theme: united
    toc: yes
    toc_depth: 4
    toc_float: yes
    number_sections: no
    code_folding: hide
---

# Aim

Expanding the work. Find a publicly available data set and apply the same workflow and adapt some of the code to make it work.

# Introduction

To look for new scRNA-seq data the [10xgenomics](10xgenomics.com) homepage was used. The [data-set](https://www.10xgenomics.com/resources/datasets/10k-human-pbmcs-3-ht-v3-1-chromium-x-3-1-high) contains Human peripheral blood mononuclear cells (PBMCs) of a healthy female donor (age: 25-30). For library generation ~16,000 cells (11,996 cells recovered) were sequenced on an Illumina NovaSeq 6000 to a read depth of approximately 40,000 mean reads per cell.
The [summary](https://cf.10xgenomics.com/samples/cell-exp/6.1.0/10k_PBMC_3p_nextgem_Chromium_X/10k_PBMC_3p_nextgem_Chromium_X_web_summary.html) shows that more than 40,000 reads per cell and app. 2000 genes per cell (median) could be detected. Also the quality scores for sequencing and mapping show quite satisfactory results.

* [DownloadLink](https://cf.10xgenomics.com/samples/cell-exp/6.1.0/10k_PBMC_3p_nextgem_Chromium_X/10k_PBMC_3p_nextgem_Chromium_X_filtered_feature_bc_matrix.tar.gz)

# TO DO
* What challenges did you face when applying the workflow to a new data set?
* What code modifications were required?
* Are the results comparable to the results of the original tutorial, or do they deviate in some unexpected ways?
* Discuss all the results and interpret them.

# Load libraries

```{r}
###################
#load libraries
###################
library(dplyr)
library(Seurat)
library(patchwork)
library(ggplot2)
```


# Setup the Seurat Object

```{r message=FALSE, warning=FALSE}
############################
#Setup the Seurat Object
############################

# Load the PBMC dataset
pbmc.data <- Read10X(data.dir = "./data_new/002/")
# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
```

# Standard pre-processing workflow

## QC and selecting cells for further analysis

* Visualize QC metrics as a violin plot

```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
# Visualize QC metrics as a violin plot
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

* FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
pbmc <- subset(pbmc, subset = nFeature_RNA > 500 & nFeature_RNA < 5000 & percent.mt < 15)
```

# Normalizing the data

```{r}
pbmc <- NormalizeData(pbmc)
```

# Identification of highly variable features (feature selection)

```{r fig.width=12, fig.height=5}
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```

# Scaling the data

```{r}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
```

# Perform linear dimensional reduction

```{r}
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
# Examine and visualize PCA results a few different ways
print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
DimPlot(pbmc, reduction = "pca")
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
```

```{r fig.height=10, fig.width=15}
DimHeatmap(pbmc, dims = 1:9, cells = 500, balanced = TRUE)
```


# Determine the ‘dimensionality’ of the dataset

```{r}
# NOTE: This process can take a long time for big datasets, comment out for expediency. More
# approximate techniques such as those implemented in ElbowPlot() can be used to reduce
# computation time
pbmc <- JackStraw(pbmc, num.replicate = 100, dims = 50)
pbmc <- ScoreJackStraw(pbmc, dims = 1:50)
JackStrawPlot(pbmc, dims = 1:40)
ElbowPlot(pbmc, ndims = 50)
```

# Cluster the cells

```{r}
pbmc <- FindNeighbors(pbmc, dims = 1:40)
pbmc <- FindClusters(pbmc, resolution = 0.1)
# Look at cluster IDs of the first 5 cells
head(Idents(pbmc), 5)
```

# Run non-linear dimensional reduction (UMAP/tSNE)

```{r}
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages =
# 'umap-learn')
pbmc <- RunUMAP(pbmc, dims = 1:40)
# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc, reduction = "umap", label = TRUE)
#UMAPPlot(pbmc)
#saveRDS(pbmc, file = "./pbmc_tutorial.rds")
```

```{r}
#run TSNE
pbmc <- RunTSNE(pbmc, dims = 1:40)
DimPlot(pbmc, reduction = "tsne", label = TRUE)
```

# Finding differentially expressed features (cluster biomarkers)

* find markers for every cluster compared to all remaining cells, report only the positive ones

```{r}
# find markers for every cluster compared to all remaining cells, report only the positive
# ones
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>%
    group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC) -> top2
top_gene <- top2$gene[seq(1, nrow(top2), 2)]
top2
```

```{r fig.height=20, fig.width=15}
VlnPlot(pbmc, features = top_gene, ncol = 3)
```

* raw counts

```{r fig.height=20, fig.width=15}
# you can plot raw counts as well
VlnPlot(pbmc, features = top_gene, slot = "counts", log = TRUE, ncol = 3)
```

* Feature plot

```{r fig.height=20, fig.width=15}
FeaturePlot(pbmc, features = top_gene, ncol = 3)
FeaturePlot(pbmc, features = top_gene, reduction = "tsne", ncol = 3)
```

* DoHeatmap

```{r fig.height=15, fig.width=10}
pbmc.markers %>%
    group_by(cluster) %>%
    top_n(n = 10, wt = avg_log2FC) -> top10
DoHeatmap(pbmc, features = top10$gene) + NoLegend()
```

# Assigning cell type identity to clusters

```{r}
new.cluster.ids <- c("Monocytes", "CD4+ T cells", "CD8+ T cells", "B cells", 
                     "CD8+ T cells (2)", "NK cells", "Unknown", 
                     "Myeloid dendritic cells", "Plasmacytoid dendritic cells")

names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "tsne", label = TRUE, pt.size = 0.5) + NoLegend()
```